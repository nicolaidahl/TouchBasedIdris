%!TEX root = ../Touch Based Idris.tex 
\chapter{Goals and Requirements}
\label{sec:GoalsAndRequirements}
When designing this product we have had specific target group in mind. 
First and foremost, the target group consists of programmers that have experience with dependent
types. In this report we will only usability test designs with people from this
target group as participants.

\section{Goals}
\label{sec:Goals}
The overall goal of this project is to investigate how the features of the dependently typed language, Idris, can improve the touch-based programming experience. 
It is important to underline that the design we will propose is meant to compete with other touch-based editor designs, and not with traditional keyboard based editors.
In other words, we are not trying to revolutionize the way we program, instead we are trying to improve the programming experience when using a touch device.
The use case for programming on a touch device will most likely be a mobile one as it is with most use cases for touch devices\,\cite[p. 26]{nielsen2013mobile}.

If the goals relate to takeaways from Chapter~\ref{sec:Analysis} the relevant takeaway will be listed in parentheses. The high-level goals of the project are:

\begin{itemize} 
	\item \textbf{G-1}: To design a programming editor that leverages Idris to provide a usable solution for the touch-based iPad device
	(Ta-12).
	\item \textbf{G-2}: The edit-compile-test cycle should be as fast as state-of-the-art iPad programming editors
	(Ta-6, Ta-12).
	\item \textbf{G-3}: Minimize the use of the virtual keyboard\,\cite[pp. 76]{nielsen2013mobile} and ideally only make use of it when inputting identifiers or auto completing terms
	(Ta-1, Ta-11, Ta-12).
	\item \textbf{G-4}: The solution should be eligible for submission to the Apple App Store (Ta-5). 
\end{itemize}

All requirements presented in the next two sections will pertain to one or
several of these goals. This is indicated in parentheses after each requirement
together with related takeaways.

\section{Usability Requirements} 
\label{sec:usability_requirements}
We will focus on a range of more specific usability requirements that have all been inspired by our analysis of existing
solutions. The interface should:

\begin{itemize}     
	\item \textbf{U-1}: Clearly communicate program structure. One way to accomplish this it through the use of visual elements such as shape, color and connecting lines (G-1)
	(Ta-18, Ta-19, Ta-20, Ta-22).
	\item \textbf{U-2}: Make use of touch gestures only when it can improve usability (G-1)
	(Ta-2, Ta-9).
	\item \textbf{U-3}: If using visual elements, avoid the pitfall of some visual languages\,\cite{green1992visual} and ensure that the program structure approximately scales to the same degree as state of the art touch-based editors (G-1)
	(Ta-17, Ta-21).
	\item \textbf{U-4}: Implement accelerators for use by the expert user but invisible for the novice user\,\cite{nielsen1990heuristic}, preferably by use of simple touch gestures (G-1, G-2, G-3)
	(Ta-1, Ta-2, Ta-4).
	\item \textbf{U-5}: Allow the user to recover from syntactical as well as logical errors in a fast manner (G-2)
	(Ta-3, Ta-6, Ta-7, Ta-8).
	\item \textbf{U-6}: Have a clear indication of where the user can add and edit terms without these indications cluttering the interface (see Section~\ref{subsub:Lisping}) (G-1)
	(Ta-10).
\end{itemize}

\section{Functional Requirements} 
\label{subsec:FunctionalRequirements} 
Besides the usability requirements listed above, the design must also enable several functional requirements. Specifically the design must:

\begin{itemize}
	\item \textbf{F-1}: Support initial pattern match creation like the Idris Emacs mode\,\cite{Idris:EmacsMode} (G-1, G-2, G-3)
	(Ta-1, Ta-2).
	\item \textbf{F-2}: Support case splitting of pattern variables like the Emacs mode\,\cite{Idris:EmacsMode} (G-1, G-2, G-3) (Ta-1, Ta-2).
	\item \textbf{F-3}: Support a way to let Idris automatically solve a metavariable like the Emacs mode\,\cite{Idris:EmacsMode} (G-1, G-2, G-3) (Ta-1, Ta-2).
	\item \textbf{F-4}: Allow the user to add, remove, and edit basic data types like \texttt{Vect} (G-1).
	\item \textbf{F-5}: Allow the user to add, remove, and edit basic functions like the \texttt{zip} function (G-1).
	\item \textbf{F-6}: Comply with the Apple App Store Review Guidelines\,\cite{AppStoreGuidelines} (G-4)
	(Ta-5).
	\item \textbf{F-7}: Include an overview of the possible language constructs that are applicable in the current context, inspired by TouchDevelop (see Section~\ref{subsub:TouchDevelop}), Lisping (see Section~\ref{subsub:Lisping}), and Eastwest (see Section~\ref{subsub:Eastwest}) (G-1, G-2, G-3)
	(Ta-11, Ta-12, Ta-13, Ta-14).
	\item \textbf{F-8}: Provide better undo support than simply shaking the device (see Section~\ref{subsub:CodeToGo}) (G-2)
	(Ta-3).
	\item \textbf{F-9}: Collapse or minimize top level declarations not currently in focus. This is inspired by TouchDevelop (see Section~\ref{subsub:TouchDevelop}) (G-2, U-3)
	(Ta-15).
	\item \textbf{F-10}: Allow for a faster way of accessing special characters (see Section~\ref{subsub:Textastic}) (G-2)
	(Ta-4).
\end{itemize}

We will refer to these goals and requirements extensively throughout the rest of this report. Appendix~\ref{chap:ListOfAllGoalsAndRequirements} includes a list of the these goals and requirements, if the reader wishes to refer to them while reading.

\section{Defining Scope} 
\label{sec:defining_scope}
We cannot implement features for all of these requirements for our first prototype, so we focus on language constructs that are essential to declaring and performing simple manipulations of the canonical \texttt{Vect} data type. This data type is, as we explained in Section~\ref{sec:DependentTypes}, often used as the basic example of how dependent types work.
Specifically, we will work towards a prototype that lets our usability test subjects define the \texttt{Vect} data type and \texttt{zip} function (also explained in
Section\ref{sec:DependentTypes}).
The \texttt{zip} function allows the testing of automatic initial clause creation, automatic case splitting, and metavariable solving.

Any language features of Idris that are not directly needed to be able to test the usability of defining the above-mentioned top-level declarations will thus be omitted in this prototype. This means we will not handle language features such as dependent pairs, with notation,
let bindings, do-notation, and case expressions.
