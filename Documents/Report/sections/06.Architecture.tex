%!TEX root = ../Touch Based Idris.tex 
\section{Architecture}
\label{sec:Architecture}

We decided to write our program for the Apple iPad, as it is the most prolific
tablet today. We also want to be able to use the various interactive features
available in the Emacs mode for Idris\todo{Ref to requirement}, such as case
splitting and auto completion. This means we need to communicate with the Idris
interpreter. The Emacs mode simply communicates with the Idris interpreter over
a socket. In this way the Emacs mode can interact with Idris, which can access
files on disk. As porting Idris to iOS is far beyond the scope of this project,
we chose to let the Idris interpreter run on a host computer, with a thin 
client running on the iPad, and a server program facilitating communication 
between the client and Idris.

\subsection{Client}
\todo{Mention the client's AST}

\subsection{Communication}
There are two layers of communication in this setup: one between the client and
the server, and one between the server and Idris. Several different strategies
exists for each layer. 

\subsubsection{Server -- Idris}
The Emacs mode for Idris communicates to the Idris slave via an s-expression
based protocol\todo{Ref}. This can be avoided by writing the server program in
Haskell, and using Idris as a library instead. This way we can call the
functions we need directly. We still have a problem though, as Idris expects
concrete textual Idris. One solution would involve transforming the AST from 
the client to concrete textual Idris, either on the server or the client. When
receiving replies from Idris, we would then have to parse textual Idris to the
client's AST\@, and send this back. An alternative is to transform the 
client's AST directly to high-level Idris syntax, and bypassing the parsing
steps in Idris, so the functions we need from Idris accept Idris AST directly.
This way we can skip the generation and parsing of concrete Idris. In the end,
we chose this solution, as it seemed cleaner, although it meant learning much
about how Idris is implemented in Haskell.
\todo{Insert diagram showing the two possibilities}

\subsubsection{Server -- Client}
This layer is somewhat less difficult. The server exposes a simple RESTful API 
over HTTP\@. This makes it easy for the client and server to communicate across
different networks. When transferring a program from client to server, we
serialize the client AST to JSON\@.

\subsection{Server}
The architecture of the server is very simple, and consists of two main 
layers. The outer layers uses the Snap Framework\todo{Ref} to implement the 
web-services. This layer also handles marshaling to and from JSON\@, which is 
implemented using the Aeson library. The inner layer handles the 
transformations to and from the Idris high level syntax, and performs the 
actual operations, such as case splitting.

\todo{Insert diagram showing overall architecture}
