%!TEX root = ../Touch Based Idris.tex
\section{Initial Design}
\label{sec:InitialDesign}

In this section we describe our initial design. It was created based on the
findings described in Section~\ref{sec:Analysis} and the requirements derived
from these in Section~\ref{sec:GoalsAndRequirements}. It mostly focuses on the
flow with which the user creates a program and not so much how the user would
edit it afterwards.

\subsection{Overall Structure}
For our initial design we wanted to create a semi-structured editor that lets
the user specify data declarations and functions in a structured but free-text way. The idea was that we would have a certain structure of text fields that
combined would amount to data and function declarations --- much like Lisping.

We adapted the way TouchDevelop manages focus. When a top-level declaration is
being edited it should have a special editable appearance that takes up more
space compared to declarations that are not in focus. This extra space ensures
that the the elements of the declaration in focus are big enough to be easily
tappable. Apple recommends that tappable elements are at least 44 points high/wide\todo{ref}, so that has been our scale measure.

We wanted to use visual elements to indicate program structure like we saw
Labview do, but as Idris is a general purpose language, the visual elements
also have to be more general. We ended up with a design that indicates a clear
hierarchy between elements, which can be seen on Figure \todo{ref}.

\missingfigure{}

At the bottom of every construct, there is a round add button from which the user can add new constructs. These will be added to the bottom. The round handle buttons connecting each construct to the higher-level vertical line
can be used for various code management purposes. For example, it should be
possible to rearrange declarations, clauses, and constructors by dragging these
handles. 

Now, if the user, for example, wishes to add a new top-level declaration somewhere in the middle of the program, the obvious way would be to use the add button and move the newly created declaration manually. We have, however, designed a faster way. Reverse-pinching two adjacent handles will create a new
declaration between the two existing ones thus eliminating the  need for rearranging declarations. This is a good example of how to use gestures as accelerators for advanced users.
The reverse-pinching gestures is not immediately discoverable (as is the
problem with advanced gestures\,\cite[p 141]{nielsen2013mobile}), but power-users will seek faster
ways to complete their tasks and naturally stumble upon documentation
describing this feature. Nielsen and Budiu\,\cite[p 143]{nielsen2013mobile} recommend
that you build this sort of redundancy into your app.

\subsection{Function Declarations}
For function declarations we had to support fast declaration of the function
type, initial pattern match creation, case splitting, and automatic
metavariable solving.

To be able to declare function types quickly it was paramount that the
interface intelligently presented you with terms that you might have use of.
When a text field takes focus, a context popover with possible terms for that position
appears right next to the field. The user only has to move the finger a few
centimeters to auto complete the field. The usability of this feature depends
on how fast and how well the contextual suggestions can be provided, and if the
user is looking for a term that is not on the top of the list, there will be a
need to start typing in the term manually until the term list in the context
eventually guesses which term is needed.

We did not want to clutter the interface with [+] buttons like Lisping does, so
one of the early problems that we needed to solve was to elegantly indicate
where new terms could be added. We came up with the solution seen in Figure
\todo{ref}. When the user starts typing in the rightmost empty text field,
a new text field pops up to indicate that further terms can be added to the
type declaration.

\missingfigure{}

Pressing the plus button will add a function clause with an initial pattern
match and name their pattern variables intelligently. Double tapping a pattern
variable will perform a case split if possible. The use of this gesture is also
a non-standard one, and a tip will have to appear one of the first times case
splitting is possible to teach the user that double tapping is possible.

Finally, metavariables,
expressed as three questions marks, can be tapped for automatic metavariable
solving. There should be clear feedback to the user regardless of the outcome
of this action.

\subsection{Data Declarations}
Early on we chose to represent data declarations in the same way as Epigram.
There is a potential readability benefit when using a more visual
representation of this type of top-level declaration that we wished to explore
with our usability tests.

The premises of the type constructor and subsequent constructors use the same flow of input as the type declaration of functions.
\todo{mention recognition rather than recall}
The reuse of the flow allows the user to learn its behavior once and then use it with a certain feeling of familiarity
in the rest of the UI\@.


\subsection{Usability Test}
\label{sec:UsabilityTest}
With a design in hand, it was time to test it. The purpose of this test was to
get an initial idea of how our ideas worked before spending time implementing
it. We created paper cutouts based on our mock-ups to represent the different
elements of the interface, with a test facilitator manipulating the cutouts to
emulate an interactive environment. See Appendix \todo{Ref} for the full report
from the test. The report includes a timestamped summary of the test, which we
will sometimes refer to in the following manner: S1.1, which refers to the
first point in the summary for subject 1.
\todo{reference the book that I referenced in my usability plan (methodology) /N}

\subsubsection{Participants}
As it is beyond the scope of this project to teach new users about dependent
types, our test participants needed experience with a programming language
featuring dependent types, ideally Idris, prior to our test. This obviously
severely limited the number of readily available candidates. Because we wanted
to conduct later tests with subjects without knowledge of earlier iterations of
the design, we limited ourselves to two test subjects for this first test. An
overview of the test subjects can be see in Table~\ref{table:first_test_subjects}.

\begin{table}[h]
\centering
\begin{tabular}{| l | l | p{5cm} | p{5cm} |}
\hline
Subject & Age & Occupation & Experience \\ \hline
\#1 & 24 & Masters student at IT-University studying programming languages & 6 months experience with Idris, several years of experience with functional languages in general \\ \hline
\#2 & 27 & Masters student at IT-University studying programming languages & 6 months experience with Idris, several years of experience with functional languages in general \\ \hline
\end{tabular}
\caption{Test subjects}
\label{table:first_test_subjects}
\end{table}

\subsubsection{Session Details}
The test was conducted in a meeting room at the IT University, with three
people present: The test subject, the test facilitator, and a note taker. The
tests were recorded. First, the test subjects were told about the project in
general. They were then told of the overall structure of the test: They would
be given two tasks, with three steps each. Each step would be explained when
they reached it. They were asked to think aloud during the test, and were told to
ask if they felt they had been stuck for a long time. Periodically, we would
ask questions about what they were thinking.

\subsubsection{Tasks}
The two tasks they were asked to complete are listed in Figure~\ref{figure:first_tasks}.
It should be noted that since the test was concerning the interface itself, and
not programming in Idris, the test subjects had access to the definitions for \texttt{Vect} and \texttt{zip} textual Idris. See Section~\ref{subsec:Idris}
for more on \texttt{Vect} and \texttt{zip}.

\begin{figure}
\centering
\begin{itemize}
	\item \textbf{Task 1}: Define a data declaration for the vector type.
	\begin{itemize}
		\item \textbf{T1.1}: Specify an identifier for the type (\texttt{Vect}), along with its type (\texttt{Nat -> Type -> Type})
		\item \textbf{T1.2}: Specify the Nil constructor (\texttt{Nil: Vect z a})
		\item \textbf{T1.3}: Specify the Cons constructor (\texttt{(::): a -> Vect k a -> Vect (S k) a})
	\end{itemize}
	\item \textbf{Task 2}: Define the zip function for vector type.
	\begin{itemize}
		\item \textbf{T2.1}: Specify the identifier for the function (\texttt{zip}), along with its type (\texttt{Vect k a -> Vect k b -> Vect k (a, b)})
		\item \textbf{T2.2}: Specify the first case (\texttt{zip Nil Nil = Nil})
		\item \textbf{T2.3}: Specify the second case (\texttt{zip x::xs y::s = (x, y) :: zip xs ys})
	\end{itemize}
\end{itemize}
\caption{Tasks for the first usability. The text in parentheses are what we considered the correct answer, and was not given to the test subjects.}
\label{figure:first_tasks}
\end{figure}

\subsubsection{Issues}
\label{sec:first_issues}
As was expected, several issues were encountered. It was quickly apparent that
the data declarations were the most problematic aspect of the design, and that
we would need to revisit their design. Task 2 on the other hand went quite
smoothly in comparison, and both subjects were impressed by the degree to
which Idris could save them from typing. We have listed the issues we
encountered below. \\ \\
\textbf{I1: Data declarations}.
The main issues our test subjects experienced had to do with the data
declarations. While both subjects had seen this way of writing types
before, it was not immediately clear to them how they should be filled out.
They did eventually get through it, but they required a great deal of help
from the test facilitator. Especially step T1.1 was difficult. (S1.1--8, S2.4, S2.9--15)\\ \\
\textbf{I2: Suggestions for parameterized types}.
When filling in a type, a popover with suggestions appear. In our mock-up,
these suggestions were always correct. But both subjects wondered how one would
fill in types that take multiple parameters. (S2.29) \\ \\
\textbf{I3: Gesture overload}
One subject wondered how to differentiate gestures for editing versus
gestures for case splitting or autocompletion. For example, double tapping on
text already has an action associated with it. (S2.34) \\ \\
\textbf{I4: Managing contexts}
After having finished step T1.3, both subjects had trouble leaving the editing
context. Only after a great deal of experimentation did they manage to leave
it. Both subjects tried to use the undo and redo buttons to change contexts.
(S1.10--13, S2.21--23)

\subsubsection{Recommendations}
\label{sec:first_recommendations}
Since issue I1 was by far the most problematic issue we discovered, we have
focused on mitigating it in our recommendations. The basic strategy is to make
it easier to understand through examples and help in the interface. If the
changes listed below are not enough, it might be necessary to completely
redesign the data declarations, perhaps by modeling them more closely after how
they look in textual Idris.

\begin{itemize}
	\item \textbf{Re1} (I1): In the text field for inputting the name and type for Data, insert an initial colon (``\texttt{:}''), separating the identifier from the type. This might make it easier to see what goes where.
	\item \textbf{Re2} (I1): Have initial hint text in text input fields, in a light color, which disappears when the fields gain focus. E.g. in the text field for the identifier, it could say ``Identifier'' or ``Name'', while the input field for the type can say ``Type''.
	\item \textbf{Re3} (I1): Differentiate borders around text fields more, to make it clear which fields have been filled, which must be filled, and which might be filled.
	\item \textbf{Re4} (I1): Show the definition for \texttt{Nat} to begin with, so the user can see an example.
	\item \textbf{Re5} (I2): Do not try to fill parameters for types, as we cannot know what they will be. Instead, just leave blank spaces so the user can fill them in.
	\item \textbf{Re6} (I3): To avoid conflict between editing and case splitting/autocompleting, implement a new gesture for ``auto'', perhaps swiping down on a term.
	
	\item \textbf{Re7} (I4): To avoid problems switching between contexts, we can remove the different contexts. This removes complexity from the interface, although it might make it harder to get a good overview of your program, as less can fit on a single screen.
\end{itemize}


\todo{section conclusion}