%!TEX root = ../Touch Based Idris.tex
\chapter{Reflection}
\label{sec:Reflection}
In this chapter, we will reflect on some of the challenges we faced, as well as on the choices we made.

\section{The Third Design Iteration}
In the third design iteration (see Chapter~\ref{sec:third_design_iteration}), we proposed large changes to the design.
In itself this is not a problem, but these changes came at a point where we no longer had time to test them.
We always planned to propose a last design after our final tests, with the goal of trying to cover any issues we discovered, however we had not planned to propose such radical changes, featuring many unknowns.
We could have proposed less drastic changes, but these would have left many issues unaddressed.

The biggest unknown is probably how the more structured approach would work out in practice.
Structured editors are not nearly as common as plain text editors, but we have not had the opportunity to look into why this is. 
One can imagine that one reason might be an increased learning curve. 
Another might be the more restricted workflow they present.
If this project was continued, these questions would need to be explored. 

\section{Process}
The initial project plan had a lot of focus on prototype development, but we
soon realized that we had to shift focus towards usability testing. We
originally intended only to provide a plan for usability testing and not
actually carry it out, but we quickly discovered that designing a usable prototype was more or less impossible without
participation from the intended users. We could probably have carried out one more
usability iteration if we had not focused on the server-side at all, and that
would most likely have resulted in a better user interface. With our
current approach we are closer to being able to fully test the
edit-compile-test cycle than we would have been only focusing on usability.

In almost all previous projects we have spent too little time on the initial literature
study, so in this project we wanted to focus more on it as is reflected by the
length of Chapter~\ref{sec:Analysis}. Retrospectively, we could have used some of this time to further develop our design and prototype. 

\section{Constraining factors}
During this project we have encountered an incredibly high amount of unforeseen constraining factors. Some of the simplest things turned out to require demanding workarounds due to the strict rules of the iOS platform and the large number of technologies and languages that had to work in combination in the finished product.

A good example of the unforeseen complexity of the simplest of components was writing a JSON parser on the client side. Most often this is a tedious task that can be left to standard or third party libraries, which was also the case on the server side in Haskell. A data definition with $n$ constructors in Haskell corresponds to one abstract class with $n$ concrete classes inheriting from the abstract class in Objective-C. It turns out that none of the most popular Objective-C JSON libraries had a good way of handling this abstraction, which forced us to spend valuable time extending a JSON library when we could have spent it on developing the UI further.

Another element that turned out to be way more time consuming than initially planned was defining and laying out the user interface for the prototype. Early on we chose to use Apple's Autolayout technology in which the programmer defines the relations between UI components declaratively just as it would be done on a white board, instead of calculating spacings and offsets on a pixel level. The idea is that the programmer defines the interface once for all screen sizes and interface orientations, but in our case Autolayout turned out to cause at least as many problems as it solved, and we found ourselves spending too much time on debugging our very custom interface.

\section{A Different Approach}
One of the underlying assumptions of this project is that it is not realistic to be able to program with the same speed and accuracy on a touch interface as with a normal keyboard. The most advanced touch-based editor is not nearly as powerful as the most advanced desktop editor/IDE\@. Keyboard-based editors have been developed for decades whereas touch gesture-based editors have not been explored to the same extent. 

In this project we have taken an existing textual programming language, originally intended for desktop programming and tested how usable we could make it. The question we ask is if it is this is the right approach. Textual programming languages have been developed with keyboard-based input in mind, but why not develop a touch-based editor with a touch-based language in mind? Such a language does not, to our knowledge, exist today. It would require developers to completely rethink the way they program and exclude any and all use of the virtual keyboard.

Imagine a solution where the programmer would only use the fastest types of touch-gestures such as swipe, tap, and double-tap, where the hands would stay in the same positions to increase programming speed. Identifiers could be specified by using the built-in microphone. One should only support a very simple language to begin with and only try to support more complex constructs when this core had been tested to work as efficiently as keyboard-based programming.

